# 8. ¿Qué es un método dunder?

## Métodos dunder o mágicos: qué son

En Python, los métodos dunder son métodos especiales que tienen un doble guión bajo al principio y al final de su nombre. Dunder es la abreviatura de double underscore.

Los métodos Dunder son métodos que permiten a las instancias de una clase interactuar con las funciones y operadores incorporados en el lenguaje. Típicamente, los métodos dunder no son invocados directamente por el programador, haciendo que parezca que son llamados por arte de magia. Por eso, a veces también se hace referencia a los métodos dunder como "métodos mágicos".

Sin embargo, los métodos dunder no se invocan por arte de magia. Simplemente son llamados implícitamente por el lenguaje, en momentos específicos que están bien definidos, y que dependen del método dunder en cuestión.

## Algunos de los métodos dunder más comunes

### \_\_init\_\_

Como hemos visto en el apartado correspondiente, es el método dunder que se utiliza para inicializar una instancia de una clase. Cuando se crea una instancia de una clase, el método **init** es llamado automáticamente por el intérprete de Python.

### **\_\_str\_\_**

Es un método dunder que se utiliza para devolver un string de una instancia de una clase. Este método se llama cuando se usa la función str() para imprimir strings de aspecto agradable para los usuarios finales, una representación legible de tu objeto.

En el siguiente ejemplo, tenemos una clase para una tienda, que tiene los atributos product y sales.

```
class Store:
  def __init__(self, product, sales):
    self.product = product
    self.sales = sales

  def __str__(self):
    return f'We have sold {self.sales} units of {self.product}.'
    

chocolate = Store('chocolate', 100)

print(str(chocolate))
# Output: We have sold 100 units of chocolate.
```

Hemos añadido el método **str** para que nos de un string de lectura agradable sobre los atributos de cada instancia.

Fijaos que no llamamos a la función mediante **str**, sino que usamos str() pasando como argumento nuestra instancia.

### \_\_repr\_\_

Así como _str_\_, el método **repr** st utiliza también para convertir una representación de un objeto a un string. La diferencia es que **repr** debe representar sin ambigüedades el objeto, preferiblemente proporcionando una expresión que pueda utilizarse para reconstruir el objeto.

Los desarrolladores pueden utilizar repr porque necesitan depurar código y tienen que asegurarse de que saben lo que están viendo.

Siguiendo con el ejemplo anterior, podemos incluir la función **repr** dentro de la clase, para que apreciemos la diferencia con **str**:

```
class Store:
  def __init__(self, product, sales):
    self.product = product
    self.sales = sales

  def __str__(self):
    return f'We have sold {self.sales} units of {self.product}.'

  def __repr__(self):
    return f"Store('{self.product}', {self.sales})"
    

chocolate = Store('chocolate', 100)

print(str(chocolate))
# Output: We have sold 100 units of chocolate.
print(repr(chocolate))
# Output: Store('chocolate', 100)
```

De forma similar al método str, la función \_\_repr\_\_ se llama mediante la sintaxis repr() tomando como argumento el objeto instanciado.

